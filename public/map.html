<!DOCTYPE html>
<html lang="en-nz">
<head>
    <title>Mapping annotations</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
    <style>
        body {
            margin: 0;
        }
        #map { 
            width: 100%;
            height: 100%; 
        }
        html, body {
            height:100%;
        }

        :root{
        --fontSize: 11px;
        }

        .pm-textarea{
            font-size: var(--fontSize);
        }
        .action-bar {
            position: absolute;
            z-index: 1000;
            right: 5px;
        }
    </style>
</head>

<body>
    <div class="action-bar">
        <button id="savebtn">
            Save
        </button>
        <button id="loadbtn">
            Load
        </button>
        <button id="clearbtn">
            Clear
        </button>
    </div>

    <div id="map"></div>

    <!-- 
    todo
    * put the map stuff in a class
    * show loading panel with getting data from db
    * surface errors during db load/save
    * setup dev db
    * split out js + css
    * store map lat/lng in db?
    * make the save etc buttons better
    -->

    <script>

        // removes all geoman layers
        function ClearAllDrawingLayers() {
            map.eachLayer(function(layer){
                if(layer instanceof L.Path || layer instanceof L.Marker){
                    layer.remove();
                }
            });
        }

        function ShowDataOnMap(data) {
            // console.log("we're in ShowDataOnMap with this data:")
            // console.log(data)
            var geoLayers = JSON.parse(data);
            for (geoLayer of geoLayers){
                //console.log("we're adding a layer of type " + geoLayer.geometry.type)
                // we have to treat point layers differently - circles and markers are built from points, but are not supported in
                // the geojson format, so we need to reconstruct them using the options we crammed in the geojson layers when no one was looking
                if(geoLayer.geometry.type === "Point") {
                    //console.log("it's a point");
                    L.geoJSON(geoLayer, {
                        pointToLayer: function (feature, latlng) {
                            // it's a marker - so it could be a circle or a marker (a marker can also be a text marker! yay!)
                            // if its got a radius then it must be a circle right?!?
                            if(feature.properties && feature.properties.radius) {
                                // console.log("it's a circle");
                                // console.log(feature.properties)
                                return L.circle(latlng, feature.properties);
                            } else {
                                // it's a marker! If it's a text marker then that is determined by the properties
                                // console.log("it's a marker");
                                // console.log(feature.properties)
                                // if we just throw the feature properies at the new marker as its options then it messes up some stuff internally on the marker (icon property)
                                // so just copy the ones we care about to maintain our marker state
                                let featureOptions = {};
                                if(feature.properties && feature.properties.textMarker == true) {
                                    featureOptions.textMarker = true;
                                    featureOptions.text = feature.properties.text;
                                }
                                //console.log(featureOptions);
                                return L.marker(latlng, featureOptions);
                            }
                        }
                    }).addTo(map);
                } else {
                    //console.log("I don't think we need to do anything special for this type of layer");
                    L.geoJSON(geoLayer).addTo(map);
                }
            }
        }

        function ShowUserMessage(type, message) {
            Toastify({
                text: message,
                duration: 10000
            }).showToast();
        }

        function LoadDataFromDb() {
            ClearAllDrawingLayers();
            //console.log("attempting to load data")

            // get the key from the query string
            const params = new Proxy(new URLSearchParams(window.location.search), {
                get: (searchParams, prop) => searchParams.get(prop),
            });
            let mapKey = params.key;
            if(mapKey) {
                // using the key, request data from the db
                let postData = { 'key' : mapKey };
                fetch('/getmapdata?' + new URLSearchParams({
                        key: mapKey
                    }), { headers: {
                            'Content-Type': 'application/json'
                    } })
                .then((response) => {
                    if(response.ok) {
                        return response.json();
                    } else {
                        return Promise.reject(response);
                    }
                })
                .then((dataResponse) => {
                    console.log("we got the data:")
                    console.log(dataResponse);
                    // we don't need the whole record, just the bit in the data field
                    ShowDataOnMap(dataResponse.Data);
                })
                .catch(err => {
                    // there's got to be a better way!
                    console.log("we're in the error handler")
                    console.log(err)
                    if(err.json) {
                        err.json().then((json) => {
                            ShowUserMessage("error", json.error)
                        })
                    } else {
                        ShowUserMessage("error", err)
                    }
                })
            } else {
                console.log("could not load data - no key supplied in query string params")
            }
        }
        

        function SaveDataToDb(){

            // we're going to check if we're editing and if we are we want to turn off editing
            // otherwise we end up saving all the temp edit shapes
            // these methods seem weirdly named, but they seem to do what we want ...?
            if(map.pm.globalEditModeEnabled()) {
                map.pm.disableGlobalEditMode();
            }

            var geoJsonLayers = [];
            
            map.eachLayer(function(layer){
                if(layer instanceof L.Path || layer instanceof L.Marker){
                    // console.log("we're saving a layer! This is the layer:")
                    // console.log(layer)
                    let geoJsonLayer = layer.toGeoJSON();
                    // cram the layer options into the geoJson layer. The options hold information that isn't supported by the 
                    // geojson format that we can use to reconstruct the layer later
                    // console.log("These are the layer.options")
                    // console.log(layer.options)
                    // set the radius - after a circle is edited the radius isn't set right??????
                    layer.options.radius = layer._mRadius;
                    geoJsonLayer.properties = layer.options;
                    //console.log("the _mRadius is " + layer._mRadius)
                    geoJsonLayers.push(geoJsonLayer);
                }
            });


            let postData = JSON.stringify({ 'key' : 'test', 'data' : geoJsonLayers});

            fetch('/setmapdata', { method: "POST", body: postData, 
                headers: {
                    'Content-Type': 'application/json'
                } })
            .then((response) => {
                if(response.ok) {
                    return response.json();
                } else {
                    console.log("error while sending map data to db; response is:");
                    console.log(response);
                }
            })
            .then((data) => {
                console.log(data);
            })

        }

        var map = L.map('map').setView([-39.19340, 173.98926], 15);
        function SetupMap() {

            L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(map);

            map.pm.addControls({  
                position: 'topleft',  
                drawCircleMarker: false,
                rotateMode: false,
            });
            LoadDataFromDb();
        }
        SetupMap();

        function ResizeTextMarkersBasedOnZoom() {
            var rootCSS = document.querySelector(':root');
            let layers = map.pm.getGeomanLayers();

            //var size = 18 * (map.getZoom() / 18);
            var size = map.getZoom() - 4;
            // set the font size in relation to the current zoom level
            rootCSS.style.setProperty('--fontSize', size+'px');
            // for each textmarker layer we need the text area to resize
            layers.forEach((layer)=>{
                if(layer.defaultOptions && layer.defaultOptions.textMarker) {
                    // we're going to force it to resize the text area by setting the content
                    let currentText = layer.pm.getText()
                    layer.pm.setText(currentText)
                }
            });
        }

        map.on('zoom zoomend',(e)=>{
            ResizeTextMarkersBasedOnZoom();
        })



        var elm = document.getElementById("savebtn");
        elm.onclick = SaveDataToDb;

        var elm = document.getElementById("loadbtn");
        elm.onclick = LoadDataFromDb;

        var elm = document.getElementById("clearbtn");
        elm.onclick = ClearAllDrawingLayers;
        

    </script>

    </body>
</html>