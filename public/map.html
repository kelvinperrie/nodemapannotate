<!DOCTYPE html>
<html lang="en-nz">
<head>
    <title>Mapping annotations</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.css" />
    <link rel="stylesheet" href="loader.css"/>
    <link rel="stylesheet" href="site.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.min.js"></script>
    <style>

    </style>
</head>

<body>
    <div class="loader">
        <!-- <div class="loader-wheel"></div> -->
        <div class="loader-text"></div>
      </div>
    <div class="action-bar">
        <button id="savebtn">
            Save
        </button>
        <button id="loadbtn">
            Load
        </button>
        <button id="clearbtn">
            Clear
        </button>
    </div>

    <div id="map"></div>

    <!-- 
    todo
    * put the map stuff in a class
    * surface errors during db load/save
    * setup dev db
    * split out js + css
    * get a better topo map
    -->

    <script>

        // get the key from the query string
        function GetMapKey() {
            const params = new Proxy(new URLSearchParams(window.location.search), {
                get: (searchParams, prop) => searchParams.get(prop),
            });
            return params.key;
        }
        // removes all geoman layers
        function ClearAllDrawingLayers() {
            map.eachLayer(function(layer){
                if(layer instanceof L.Path || layer instanceof L.Marker){
                    layer.remove();
                }
            });
        }

        function ShowDataOnMap(config, data) {
            // console.log("we're in ShowDataOnMap with this data:")
            // console.log(data)

            // configure the map as per data from db
            let configJson =  JSON.parse(config);
            if(configJson) {
                map.setView(new L.LatLng(configJson.center.lat, configJson.center.lng), configJson.zoom);
            }

            var geoLayers = JSON.parse(data);
            for (geoLayer of geoLayers){
                //console.log("we're adding a layer of type " + geoLayer.geometry.type)
                // we have to treat point layers differently - circles and markers are built from points, but are not supported in
                // the geojson format, so we need to reconstruct them using the options we crammed in the geojson layers when no one was looking
                if(geoLayer.geometry.type === "Point") {
                    //console.log("it's a point");
                    L.geoJSON(geoLayer, {
                        pointToLayer: function (feature, latlng) {
                            // it's a marker - so it could be a circle or a marker (a marker can also be a text marker! yay!)
                            // if its got a radius then it must be a circle right?!?
                            if(feature.properties && feature.properties.radius) {
                                // console.log("it's a circle");
                                // console.log(feature.properties)
                                return L.circle(latlng, feature.properties);
                            } else {
                                // it's a marker! If it's a text marker then that is determined by the properties
                                // console.log("it's a marker");
                                // console.log(feature.properties)
                                // if we just throw the feature properies at the new marker as its options then it messes up some stuff internally on the marker (icon property)
                                // so just copy the ones we care about to maintain our marker state
                                let featureOptions = {};
                                if(feature.properties && feature.properties.textMarker == true) {
                                    featureOptions.textMarker = true;
                                    featureOptions.text = feature.properties.text;
                                }
                                //console.log(featureOptions);
                                return L.marker(latlng, featureOptions);
                            }
                        }
                    }).addTo(map);
                } else {
                    //console.log("I don't think we need to do anything special for this type of layer");
                    L.geoJSON(geoLayer).addTo(map);
                }
            }
            HideLoadingPanel();
        }

        function LoadDataFromDb() {
            ShowLoadingPanel();
            ClearAllDrawingLayers();
            //console.log("attempting to load data")

            let mapKey = GetMapKey();
            if(mapKey) {
                // using the key, request data from the db
                let postData = { 'key' : mapKey };
                fetch('/getmapdata?' + new URLSearchParams({
                    key: mapKey
                }), { headers: {
                        'Content-Type': 'application/json'
                } })
                .then((response) => {
                    if(response.ok) {
                        return response.json();
                    } else {
                        console.log("error while getting map data; response is:");
                        console.log(response);
                    }
                })
                .then((dataResponse) => {
                    // console.log("we got the data:")
                    // console.log(dataResponse);
                    // we don't need the whole record, just the bit in the data field
                    ShowDataOnMap(dataResponse.Config,dataResponse.Data);
                })
            } else {
                console.log("could not load data - no key supplied in query string params")
                HideLoadingPanel();
            }
        }
        

        function SaveDataToDb(){

            // we're going to check if we're editing and if we are we want to turn off editing
            // otherwise we end up saving all the temp edit shapes
            // these methods seem weirdly named, but they seem to do what we want ...?
            if(map.pm.globalEditModeEnabled()) {
                map.pm.disableGlobalEditMode();
            }

            let mapKey = GetMapKey();
            if(!mapKey) {
                console.log("can't save because there's no key")
                // show user an error
                return;
            }

            var geoJsonLayers = [];
            
            map.eachLayer(function(layer){
                if(layer instanceof L.Path || layer instanceof L.Marker){
                    // console.log("we're saving a layer! This is the layer:")
                    // console.log(layer)
                    let geoJsonLayer = layer.toGeoJSON();
                    // cram the layer options into the geoJson layer. The options hold information that isn't supported by the 
                    // geojson format that we can use to reconstruct the layer later
                    // console.log("These are the layer.options")
                    // console.log(layer.options)
                    // set the radius - after a circle is edited the radius isn't set right??????
                    layer.options.radius = layer._mRadius;
                    geoJsonLayer.properties = layer.options;
                    //console.log("the _mRadius is " + layer._mRadius)
                    geoJsonLayers.push(geoJsonLayer);
                }
            });

            let mapConfigJson = {
                center : map.getCenter(),
                zoom : map.getZoom()
            }

            let postData = JSON.stringify({ 'key' : mapKey, 'data' : geoJsonLayers, 'config' : mapConfigJson});

            fetch('/setmapdata', { method: "POST", body: postData, 
                headers: {
                    'Content-Type': 'application/json'
                } })
            .then((response) => {
                if(response.ok) {
                    return response.json();
                } else {
                    console.log("error while sending map data to db; response is:");
                    console.log(response);
                }
            })
            .then((data) => {
                console.log(data);
            })

        }

        var map = L.map('map').setView([-39.19340, 173.98926], 15);
        function SetupMap() {

            // possible maps https://leaflet-extras.github.io/leaflet-providers/preview/

            // sat images
            // var Esri_WorldImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            //     attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
            // });

            // topo map
            // https://tile.thunderforest.com/outdoors/{z}/{x}/{y}.png?apikey=6ceeda90965642818c0223946515f2e5

            // create a new tile layer
            // var tileUrl = 'https://tile.thunderforest.com/cycle/{z}/{x}/{y}.png?apikey=<insert-your-apikey-here>',
            // layer = new L.TileLayer(tileUrl, {maxZoom: 18});

            // add the layer to the map
            // map.addLayer(layer);

            var Thunderforest_Outdoors = L.tileLayer('https://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}.png?apikey={apikey}', {
                attribution: '&copy; <a href="http://www.thunderforest.com/">Thunderforest</a>, &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                apikey: '6ceeda90965642818c0223946515f2e5',
                maxZoom: 22
            }).addTo(map);;

            // open topo map
            // var OpenTopoMap = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            //     maxZoom: 17,
            //     attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
            // });


            // L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            //     maxZoom: 19,
            //     attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            // }).addTo(map);

            map.pm.addControls({  
                position: 'topleft',  
                drawCircleMarker: false,
                rotateMode: false,
            });
            LoadDataFromDb();
        }
        SetupMap();

        function ResizeTextMarkersBasedOnZoom() {
            var rootCSS = document.querySelector(':root');
            let layers = map.pm.getGeomanLayers();

            //var size = 18 * (map.getZoom() / 18);
            var size = map.getZoom() - 4;
            // set the font size in relation to the current zoom level
            rootCSS.style.setProperty('--fontSize', size+'px');
            // for each textmarker layer we need the text area to resize
            layers.forEach((layer)=>{
                if(layer.defaultOptions && layer.defaultOptions.textMarker) {
                    // we're going to force it to resize the text area by setting the content
                    let currentText = layer.pm.getText()
                    layer.pm.setText(currentText)
                }
            });
        }

        function ShowLoadingPanel() {
            document.getElementsByClassName('loader')[0].style.display  = 'block';
        }
        function HideLoadingPanel() {
            document.getElementsByClassName('loader')[0].style.display  = 'none';
        }

        map.on('zoom zoomend',(e)=>{
            ResizeTextMarkersBasedOnZoom();
        })



        var elm = document.getElementById("savebtn");
        elm.onclick = SaveDataToDb;

        var elm = document.getElementById("loadbtn");
        elm.onclick = LoadDataFromDb;

        var elm = document.getElementById("clearbtn");
        elm.onclick = ClearAllDrawingLayers;
        

    </script>

    </body>
</html>