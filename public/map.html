<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
<link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.min.js"></script>
<style>
    body {
        margin: 0;
    }
    #map { 
        width: 100%;
        height: 100%; 
    }

    :root{
       --fontSize: 13px;
    }

    .pm-textarea{
        font-size: var(--fontSize);
    }
    .action-bar {
        position: absolute;
        z-index: 1000;
        right: 5px;
    }
 </style>

<div class="action-bar">
    <button id="savebtn">
        Save
    </button>
    <button id="loadbtn">
        Load
    </button>
    <button id="clearbtn">
        Clear
    </button>
</div>

<div id="map"></div>



<script>

    function ClearAllDrawingLayers() {
        map.eachLayer(function(layer){
            if(layer instanceof L.Path || layer instanceof L.Marker){
                console.log(layer)
                layer.remove();
            }
        });
    }

    function ShowDataOnMap(data) {
        console.log("we're in ShowDataOnMap with this data:")
        console.log(data)
        var geoLayers = JSON.parse(data);
        for (geoLayer of geoLayers){
            console.log("we're adding a layer of type " + geoLayer.geometry.type)
            // we have to treat point layers differently - circles and markers are built from points, but are not supported in
            // the geojson format, so we need to reconstruct them using the options we crammed in the geojson layers when no one was looking
            if(geoLayer.geometry.type === "Point") {
                console.log("it's a point");
                L.geoJSON(geoLayer, {
                    pointToLayer: function (feature, latlng) {
                        // it's a marker - so it could be a circle or a marker (a marker can also be a text marker! yay!)
                        // if its got a radius then it must be a circle right?!?
                        if(feature.properties && feature.properties.radius) {
                            console.log("it's a circle");
                            console.log(feature.properties)
                            return L.circle(latlng, feature.properties);
                        } else {
                            // it's a marker! If it's a text marker then that is determined by the properties
                            console.log("it's a marker");
                            console.log(feature.properties)
                            // if we just throw the feature properies at the new marker as its options then it messes up some stuff internally on the marker (icon property)
                            // so just copy the ones we care about to maintain our marker state
                            let featureOptions = {};
                            if(feature.properties && feature.properties.textMarker == true) {
                                featureOptions.textMarker = true;
                                featureOptions.text = feature.properties.text;
                            }
                            console.log(featureOptions);
                            return L.marker(latlng, featureOptions);
                        }
                    }
                }).addTo(map);
            } else {
                console.log("I don't think we need to do anything special for this type of layer");
                L.geoJSON(geoLayer).addTo(map);
            }
        }
    }

    function LoadDataFromDb() {
        ClearAllDrawingLayers();
        console.log("attempting to load data")

        // get the key from the query string
        const params = new Proxy(new URLSearchParams(window.location.search), {
            get: (searchParams, prop) => searchParams.get(prop),
        });
        let mapKey = params.key;
        if(mapKey) {
            // using the key, request data from the db
            let postData = { 'key' : mapKey };
            fetch('/getmapdata?' + new URLSearchParams({
                key: mapKey
            }), { headers: {
                    'Content-Type': 'application/json'
            } })
            .then((response) => {
                if(response.ok) {
                    return response.json();
                } else {
                    console.log("error while getting map data; response is:");
                    console.log(response);
                }
            })
            .then((dataResponse) => {
                console.log("we got the data:")
                console.log(dataResponse);
                // we don't need the whole record, just the bit in the data field
                ShowDataOnMap(dataResponse.Data);
            })
        } else {
            console.log("could not load data - no key supplied in query string params")
        }
    }
    

    function saveDataToDb(){

        // we're going to check if we're editing and if we are we want to turn off editing
        // otherwise we end up saving all the temp edit shapes
        // these methods seem weirdly named, but they seem to do what we want ...?
        if(map.pm.globalEditModeEnabled()) {
            console.log("stopping editing!")
            map.pm.disableGlobalEditMode();
        }

        //var allLayers = L.featureGroup();
        var geoJsonLayers = [];
        
        map.eachLayer(function(layer){
            if(layer instanceof L.Path || layer instanceof L.Marker){
                //allLayers.addLayer(layer);
                console.log("we're saving a layer! This is the layer:")
                console.log(layer)
                let geoJsonLayer = layer.toGeoJSON();
                // cram the layer options into the geoJson layer. The options hold information that isn't supported by the 
                // geojson format that we can use to reconstruct the layer later
                console.log("These are the layer.options")
                console.log(layer.options)
                //layer.options.radius = layer._radius;
                // set the radius - after a circle is edited the radius isn't set right??????
                layer.options.radius = layer._mRadius;
                geoJsonLayer.properties = layer.options;
                //console.log(geoJsonLayer);
                console.log("the _mRadius is " + layer._mRadius)
                geoJsonLayers.push(geoJsonLayer);
            }
        });

        //let jsonLayersData = JSON.stringify(geoJsonLayers);

        let postData = JSON.stringify({ 'key' : 'test', 'data' : geoJsonLayers});
        console.log("about to send data from map.html on save")
        console.log(postData)

        fetch('/setmapdata', { method: "POST", body: postData, 
            headers: {
                'Content-Type': 'application/json'
            } })
        .then((response) => {
            if(response.ok) {
                return response.json();
            } else {
                console.log("RUH ROH error while Setting map data");
            }
        })
        .then((data) => {
            console.log(data);
            console.log("i just set map data")
        })

        //localStorage.setItem('data', JSON.stringify(geoJsonLayers));
    }

    var map = L.map('map').setView([-39.19340, 173.98926], 15);
    function SetupMap() {

        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);

        map.pm.addControls({  
            position: 'topleft',  
            drawCircleMarker: false,
            rotateMode: false,
        });
        LoadDataFromDb();
    }
    //setTimeout(SetupMap,2000)
    SetupMap();


    // this is sample code to resize text when zoom occurs
    var layer;
    // listen to when a new layer is created
    map.on('pm:create', function(e) {
        layer = e.layer;
    });
    var rootCSS = document.querySelector(':root');
    map.on('zoom zoomend',(e)=>{
        console.log("map has zoomed or zoom ended")
        // map.eachLayer(function(layer){
        //     if(layer){
        //         var size = 18 * (map.getZoom() / 18);
        //         console.log(size, map.getZoom())
        //         rootCSS.style.setProperty('--fontSize', size+'px');
        //         layer.pm._autoResize();
        //     }
        // })
    })



    var elm = document.getElementById("savebtn");
    elm.onclick = saveDataToDb;

    var elm = document.getElementById("loadbtn");
    elm.onclick = LoadDataFromDb;

    var elm = document.getElementById("clearbtn");
    elm.onclick = ClearAllDrawingLayers;
    

</script>